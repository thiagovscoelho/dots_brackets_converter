<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The Dots–Brackets Converter (Refactored)</title>
  <style>
    body {
      font-family: sans-serif;
      max-width: 800px;
      margin: 2em auto;
      padding: 0 1em;
    }
    h1 {
      text-align: center;
    }
    textarea,
    pre {
      width: 100%;
      font-family: monospace;
      font-size: 1rem;
    }
    .controls {
      margin: 1em 0;
    }
    .controls label {
      margin-right: 1em;
    }
    button {
      padding: 0.5em 1em;
      font-size: 1rem;
    }
    pre {
      background: #f5f5f5;
      padding: 1em;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <h1>The Dots–Brackets Converter</h1>

  <!-- === UI === -->
  <div class="controls">
    <label><input type="radio" name="mode" value="dotsToBrackets" checked> Dots → Brackets</label>
    <label><input type="radio" name="mode" value="bracketsToDots"> Brackets → Dots</label>
  </div>
  <textarea id="inputFormula" rows="4" placeholder="Enter your formula..."></textarea>
  <div class="controls">
    <button id="convertBtn">Convert</button>
  </div>
  <pre id="outputFormula"></pre>

  <!-- === Logic === -->
  <script type="module">
    /*
     *  Dots ⇄ Brackets converter, refactored for clarity & maintainability.
     *  The public API surface is unchanged so existing behaviour stays intact.
     *  Key refactor points:
     *    • Single, param‑driven lexer instead of two almost‑identical copies.
     *    • Strategy‑based parser so dot/bracket precedence rules live side‑by‑side.
     *    • Pure functions + tiny helpers → easier unit‑testing.
     *    • Constants & regex construction in one place – no duplication.
     *    • UI wiring kept minimal and framework‑agnostic.
     */

    /*********************
     *  Shared Utilities  *
     *********************/

    /** Escape a string so it can be safely used inside a RegExp constructor. */
    const reEsc = (s) => s.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");

    /** Count weight‑dots/colons. */
    const countDots = (s) => (s.match(/\./g) || []).length + (s.match(/:/g) || []).length * 2;

    /** Build the dotted operator representation from a weight. */
    function dottedRep(weight, op) {
      let left, right;
      if (weight % 2 === 0) {
        const c = ":".repeat(weight / 2);
        left = right = c;
      } else {
        const c = ":".repeat((weight - 1) / 2);
        left = "." + c;
        right = c + ".";
      }
      return left + op + right;
    }

    /***********************
     *  Token Definitions  *
     ***********************/

    // Supported binary operators (order doesn’t matter – we sort later).
    const OPERATORS = [
      "&&",
      "||",
      "∥",
      "⇔",
      "⇋",
      "↔",
      "⇏",
      "⊅",
      "⇎",
      "↛",
      "⇍",
      "⇒",
      "⊃",
      "→",
      "∧",
      "•",
      "⋅",
      "&",
      "↑",
      "∨",
      "+",
      "∣",
      "|",
      "↓",
      "⊙",
      "⊕",
      "≡",
      "≢",
      "↮",
      "⇐",
      "⊂",
      "←",
      "⊄",
      "↚",
      "=",
      "=Df",
      "=Df.",
      "=df",
      "=df.",
    ];

    // Compile operator patterns (longest first to avoid prefix clashes).
    const OP_PATTERN = OPERATORS.map(reEsc).sort((a, b) => b.length - a.length).join("|");

    // Regexes used by the lexer (shared).
    const REGEX = {
      /** full dotted‑op ‑ left dots, op, right dots */
      dottedBinary: new RegExp(`^([.:]*)\\s*(${OP_PATTERN})\\s*([.:]*)`),
      /** bare operator (no dots) */
      binary: new RegExp(`^(${OP_PATTERN})`),
      /** quantifiers: (∀x)  ∀x   (x) (binding‑var) */
      quantParen: /^\(\s*(∀|∃)([A-Za-z\u0370-\u03FF][A-Za-z0-9\u0370-\u03FF]*)\s*\)/,
      quant: /^(∀|∃)([A-Za-z\u0370-\u03FF][A-Za-z0-9\u0370-\u03FF]*)/,
      bindVarParen: /^\(\s*([A-Za-z\u0370-\u03FF])\s*\)/,
      /** negations */
      neg: /^(NOT|¬|−|∼|~)/,
      /** atom / predicate names */
      atomName: /^[A-Za-z\u0370-\u03FF][A-Za-z0-9\u0370-\u03FF]*/,
      /** whitespace */
      ws: /^\s+/,
    };

    /** Token‑factory helpers */
    const T = {
      Atom: (v) => ({ type: "Atom", value: v }),
      Not: (op) => ({ type: "Not", op }),
      Quant: (sym, varName) => ({ type: "Quant", sym, varName }),
      Binary: (op, weight) => ({ type: "Binary", op, weight }),
      LParen: { type: "LPAREN" },
      RParen: { type: "RPAREN" },
    };

    /****************
     *  Lexer (one) *
     ****************/

    /**
     * Tokenise a formula string.
     * @param {string} input
     * @param {"dots"|"brackets"} notationMode – determines how binary operators are recognised.
     * @returns {Array<Token>}
     */
    function lexer(input, notationMode) {
      // Normalise square‑brackets → parentheses.
      let s = input.replace(/\[/g, "(").replace(/\]/g, ")");
      const tokens = [];

      while (s.length) {
        // --- whitespace ------------------------------------
        const ws = s.match(REGEX.ws);
        if (ws) {
          s = s.slice(ws[0].length);
          continue;
        }

        // --- atom / predicate ------------------------------
        if (REGEX.atomName.test(s)) {
          const name = s.match(REGEX.atomName)[0];
          let full = name;
          let rest = s.slice(name.length);
          // Grab argument list if any.
          if (rest[0] === "(") {
            let depth = 1;
            let i = 1;
            while (i < rest.length && depth) {
              if (rest[i] === "(") depth++;
              else if (rest[i] === ")") depth--;
              i++;
            }
            if (depth !== 0) throw new Error("Unmatched parentheses in predicate");
            full += rest.slice(0, i);
            rest = rest.slice(i);
          }
          tokens.push(T.Atom(full));
          s = rest;
          continue;
        }

        // --- quantifiers ----------------------------------
        let m;
        if ((m = s.match(REGEX.quantParen))) {
          tokens.push(T.Quant(m[1], m[2]));
          s = s.slice(m[0].length);
          continue;
        }
        if ((m = s.match(REGEX.quant))) {
          tokens.push(T.Quant(m[1], m[2]));
          s = s.slice(m[0].length);
          continue;
        }
        if ((m = s.match(REGEX.bindVarParen))) {
          tokens.push(T.Quant(null, m[1]));
          s = s.slice(m[0].length);
          continue;
        }

        // --- negation -------------------------------------
        if ((m = s.match(REGEX.neg))) {
          tokens.push(T.Not(m[1]));
          s = s.slice(m[0].length);
          continue;
        }

        // --- binary operator -------------------------------
        if (notationMode === "dots") {
          if ((m = s.match(REGEX.dottedBinary))) {
            const [, ldots, op, rdots] = m;
            const weight = countDots(ldots);
            if (countDots(rdots) !== weight) throw new Error("Mismatched dots: " + m[0]);
            tokens.push(T.Binary(op, weight));
            s = s.slice(m[0].length);
            continue;
          }
        } else {
          if ((m = s.match(REGEX.binary))) {
            tokens.push(T.Binary(m[1], 0));
            s = s.slice(m[0].length);
            continue;
          }
        }

        // --- parentheses ----------------------------------
        if (s[0] === "(") {
          tokens.push(T.LParen);
          s = s.slice(1);
          continue;
        }
        if (s[0] === ")") {
          tokens.push(T.RParen);
          s = s.slice(1);
          continue;
        }

        // --- anything else → error ------------------------
        throw new Error("Unexpected character: " + s[0]);
      }

      return tokens;
    }

    /*****************
     *  Parser base  *
     *****************/

    /**
     * Walk helper that executes a callback on binary nodes.
     */
    const walkBinary = (node, fn) => {
      if (!node) return;
      if (node.type === "Binary") fn(node);
      if (node.type === "Binary") {
        walkBinary(node.left, fn);
        walkBinary(node.right, fn);
      } else if (node.type === "Not" || node.type === "Quant") {
        walkBinary(node.child, fn);
      }
    };

    /**
     * Parse for dot‑notation.
     * Uses operator weight to create precedence levels.
     */
    function parseDots(tokens) {
      if (!tokens.length) return null;

      // Highest weight → lowest precedence.
      const maxWeight = Math.max(
        0,
        ...tokens.filter((t) => t.type === "Binary").map((t) => t.weight)
      );

      // Re‑map so that weight 0 == highest precedence.
      tokens.forEach((t) => {
        if (t.type === "Binary") t.weight = maxWeight - t.weight;
      });

      let idx = 0;

      function parseLevel(level) {
        if (level > maxWeight) return parsePrimary();
        let node = parseLevel(level + 1);
        const nodes = [node];
        const ops = [];
        while (tokens[idx] && tokens[idx].type === "Binary" && tokens[idx].weight === level) {
          ops.push(tokens[idx].op);
          idx++;
          nodes.push(parseLevel(level + 1));
        }
        // Right fold to preserve grouping order.
        let subtree = nodes.pop();
        while (nodes.length) {
          const left = nodes.pop();
          const op = ops.pop();
          subtree = { type: "Binary", op, left, right: subtree };
        }
        return subtree;
      }

      function parsePrimary() {
        const t = tokens[idx];
        if (!t) return null;
        switch (t.type) {
          case "Atom":
            idx++;
            return t;
          case "Not":
            idx++;
            return { type: "Not", op: t.op, child: parsePrimary() };
          case "Quant":
            idx++;
            return { type: "Quant", sym: t.sym, varName: t.varName, child: parsePrimary() };
          case "LPAREN":
            idx++;
            const expr = parseLevel(0);
            if (tokens[idx] && tokens[idx].type === "RPAREN") idx++;
            return expr;
          default:
            throw new Error("Parse error at token " + JSON.stringify(t));
        }
      }

      return parseLevel(0);
    }

    /**
     * Left‑associative, parentheses‑only precedence parser (bracket notation).
     */
    function parseBrackets(tokens) {
      let idx = 0;

      function parseExpr() {
        let node = parsePrimary();
        while (tokens[idx] && tokens[idx].type === "Binary") {
          const opTok = tokens[idx++];
          const right = parseExpr(); // right‑recursive → left‑associative
          node = { type: "Binary", op: opTok.op, left: node, right };
        }
        return node;
      }

      function parsePrimary() {
        const t = tokens[idx];
        if (!t) return null;
        switch (t.type) {
          case "Atom":
            idx++;
            return t;
          case "Not":
            idx++;
            return { type: "Not", op: t.op, child: parsePrimary() };
          case "Quant":
            idx++;
            return { type: "Quant", sym: t.sym, varName: t.varName, child: parsePrimary() };
          case "LPAREN":
            idx++;
            const expr = parseExpr();
            if (tokens[idx] && tokens[idx].type === "RPAREN") idx++;
            return expr;
          default:
            throw new Error("Parse error at token " + JSON.stringify(t));
        }
      }

      return parseExpr();
    }

    /*****************
     *  Annotation   *
     *****************/

    /** Annotate depths (for later dot‑serialization). */
    function annotateDepth(node, depth = 0) {
      if (!node) return;
      if (node.type === "Binary") {
        node.depth = depth;
        annotateDepth(node.left, depth + 1);
        annotateDepth(node.right, depth + 1);
      } else if (node.type === "Not" || node.type === "Quant") {
        annotateDepth(node.child, depth);
      }
    }

    /** Assign dot‑weights based on annotated depth (root = max weight). */
    function assignWeights(node) {
      const binaries = [];
      walkBinary(node, (n) => binaries.push(n));
      const maxD = binaries.length ? Math.max(...binaries.map((n) => n.depth)) : 0;
      binaries.forEach((n) => (n.weight = maxD - n.depth));
    }

    /*********************
     *  Serialisation    *
     *********************/

    function toBrackets(node, root = true) {
      switch (node.type) {
        case "Atom":
          return node.value;
        case "Not": {
          const ch = toBrackets(node.child, false);
          return node.op + (ch.startsWith("(") ? ch : ch);
        }
        case "Quant": {
          const prefix = node.sym ? `(${node.sym}${node.varName})` : `(${node.varName})`;
          return prefix + toBrackets(node.child, false);
        }
        case "Binary": {
          const left = toBrackets(node.left, false);
          const right = toBrackets(node.right, false);
          const str = `${left} ${node.op} ${right}`;
          return root ? str : `(${str})`;
        }
      }
    }

    function toDots(node) {
      switch (node.type) {
        case "Atom":
          return node.value;
        case "Not": {
          // If child is a binary, keep brackets for clarity.
          const body = node.child.type === "Binary" ? toBrackets(node.child, false) : toDots(node.child);
          return node.op + body;
        }
        case "Quant": {
          const prefix = node.sym ? `(${node.sym}${node.varName})` : `(${node.varName})`;
          const body = toDots(node.child);
          return ["Atom", "Not", "Quant"].includes(node.child.type) ? prefix + body : `${prefix}(${body})`;
        }
        case "Binary": {
          const left = toDots(node.left);
          const right = toDots(node.right);
          return `${left} ${dottedRep(node.weight, node.op)} ${right}`;
        }
      }
    }

    /****************
     *  UI Binding  *
     ****************/

    const qs = (sel) => document.querySelector(sel);
    const $in = qs("#inputFormula");
    const $out = qs("#outputFormula");

    qs("#convertBtn").addEventListener("click", () => {
      const mode = qs("input[name=mode]:checked").value;
      const val = $in.value.trim();
      try {
        let ast, result;
        if (mode === "dotsToBrackets") {
          const tokens = lexer(val, "dots");
          ast = parseDots(tokens);
          result = toBrackets(ast);
        } else {
          const tokens = lexer(val, "brackets");
          ast = parseBrackets(tokens);
          annotateDepth(ast);
          assignWeights(ast);
          result = toDots(ast);
        }
        $out.textContent = result;
      } catch (err) {
        $out.textContent = "Error: " + err.message;
      }
    });
  </script>
</body>
</html>
