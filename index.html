<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The Dots–Brackets Converter</title>
  <style>
    body {
      font-family: sans-serif;
      max-width: 800px;
      margin: 2em auto;
      padding: 0 1em;
    }
    h1 {
      text-align: center;
    }
    textarea,
    pre {
      width: 100%;
      font-family: monospace;
      font-size: 1rem;
    }
    .controls {
      margin: 1em 0;
    }
    .controls label {
      margin-right: 1em;
    }
    button {
      padding: 0.5em 1em;
      font-size: 1rem;
    }
    pre {
      background: #f5f5f5;
      padding: 1em;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <h1>The Dots–Brackets Converter</h1>
  <p>See <a href="https://github.com/thiagovscoelho/dots_brackets_converter">the project page on Github</a> for more information on this project.</p>
  <!-- === UI === -->
  <div class="controls">
    <label><input type="radio" name="mode" value="dotsToBrackets" checked> Dots → Brackets</label>
    <label><input type="radio" name="mode" value="bracketsToDots"> Brackets → Dots</label>
  </div>
  <textarea id="inputFormula" rows="4" placeholder="Enter your formula..."></textarea>
  <div class="controls">
    <button id="convertBtn">Convert</button>
  </div>
  <div class="controls" id="dotNegOption" style="display:none">
  <label><input type="checkbox" id="dotNegChk"> Dot molecular negation</label>
  <label style="margin-left:1em;"><input type="checkbox" id="strictHierChk"> Use stricter hierarchy</label>
  </div>
  <pre id="outputFormula"></pre>

  <!-- === Logic === -->
  <script type="module">
    /*
     *  Dots ⇄ Brackets converter, refactored for clarity & maintainability.
     *  The public API surface is unchanged so existing behaviour stays intact.
     *  Key refactor points:
     *    • Single, param‑driven lexer instead of two almost‑identical copies.
     *    • Strategy‑based parser so dot/bracket precedence rules live side‑by‑side.
     *    • Pure functions + tiny helpers → easier unit‑testing.
     *    • Constants & regex construction in one place – no duplication.
     *    • UI wiring kept minimal and framework‑agnostic.
     */
     
    /*********************
    *  Serial utilities *
    *********************/

    /* helper: build a dot/colon string of weight w */
    const dotStr = (w) =>
      w === 0
        ? ""
        : w % 2 === 0
            ? ":".repeat(w / 2)
            : "." + ":".repeat((w - 1) / 2);


    /*********************
     *  Shared Utilities  *
     *********************/

    /** Escape a string so it can be safely used inside a RegExp constructor. */
    const reEsc = (s) => s.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");

    /** Count weight‑dots/colons. */
    const countDots = (s) => (s.match(/\./g) || []).length + (s.match(/:/g) || []).length * 2;

    /** Build the dotted operator representation from a weight. */
    function dottedRep(weight, op) {
      let left, right;
      if (weight % 2 === 0) {
        const c = ":".repeat(weight / 2);
        left = right = c;
      } else {
        const c = ":".repeat((weight - 1) / 2);
        left = "." + c;
        right = c + ".";
      }
      return left + op + right;
    }

    /***********************
     *  Token Definitions  *
     ***********************/

    // Supported binary operators (order doesn’t matter – we sort later).
    const OPERATORS = [
      "&&",
      "||",
      "∥",
      "⇔",
      "⇋",
      "↔",
      "⇏",
      "⊅",
      "⇎",
      "↛",
      "⇍",
      "⇒",
      "⊃",
      "→",
      "∧",
      "•",
      "⋅",
      "&",
      "↑",
      "∨",
      "+",
      "∣",
      "|",
      "↓",
      "⊙",
      "⊕",
      "≡",
      "≢",
      "↮",
      "⇐",
      "⊂",
      "←",
      "⊄",
      "↚",
      "=",
      "=Df",
      "=Df.",
      "=df",
      "=df.",
    ];

    // Compile operator patterns (longest first to avoid prefix clashes).
    const OP_PATTERN = OPERATORS.map(reEsc).sort((a, b) => b.length - a.length).join("|");

    // Regexes used by the lexer (shared).
    const REGEX = {
      /** full dotted‑op ‑ left dots, op, right dots */
      dottedBinary: new RegExp(`^([.:]*)\\s*(${OP_PATTERN})\\s*([.:]*)`),
      /** bare operator (no dots) */
      binary: new RegExp(`^(${OP_PATTERN})`),
      /** quantifiers: (∀x)  ∀x   (x) (binding‑var) */
      quantParen: /^\(\s*(∀|∃)([A-Za-z\u0370-\u03FF][A-Za-z0-9\u0370-\u03FF]*)\s*\)/,
      quant: /^(∀|∃)([A-Za-z\u0370-\u03FF][A-Za-z0-9\u0370-\u03FF]*)/,
      bindVarParen: /^\(\s*([A-Za-z\u0370-\u03FF][A-Za-z0-9\u0370-\u03FF]*)\s*\)/,
      /** negations */
      neg: /^(NOT|¬|−|∼|~)/,
      /** atom / predicate names */
      atomName: /^[A-Za-z\u0370-\u03FF][A-Za-z0-9\u0370-\u03FF]*/,
      /** whitespace */
      ws: /^\s+/,
      dottedNeg : /^([.:]*)\s*(NOT|¬|−|∼|~)\s*([.:]*)/,
    };

    /** Token‑factory helpers */
    const T = {
      Atom: (v) => ({ type: "Atom", value: v }),
      Not  : (op, weight = undefined) => ({ type: "Not", op, weight }),
      Quant: (sym, varName) => ({ type: "Quant", sym, varName }),
      Binary: (op, weight) => ({ type: "Binary", op, weight }),
      LParen: { type: "LPAREN" },
      RParen: { type: "RPAREN" },
      IotaQuant: (varName, desc) => ({ type: "IotaQuant", varName, desc }),
    };

    /****************
     *  Lexer (one) *
     ****************/

    /**
     * Tokenise a formula string.
     * @param {string} input
     * @param {"dots"|"brackets"} notationMode – determines how binary operators are recognised.
     * @returns {Array<Token>}
     */
    function lexer(input, notationMode) {
      // Normalise square‑brackets → parentheses.
      let s = input.replace(/\[/g, "(").replace(/\]/g, ")");
      const tokens = [];

      while (s.length) {
        // --- whitespace ------------------------------------
        const ws = s.match(REGEX.ws);
        if (ws) {
          s = s.slice(ws[0].length);
          continue;
        }
        
        // --- iota-quantifier  ((ιx)(ϕx)) ------------------------
        if (s.startsWith("((")) {
          const skipWS = () => { while (/\s/.test(s[pos])) pos++; };
          let pos = 2;                           // after '(('
          skipWS();
          if (s[pos] === "ι") {
            pos++;
            const mVar = s.slice(pos).match(/^([A-Za-z\u0370-\u03FF][A-Za-z0-9\u0370-\u03FF]*)/);
            if (mVar) {
              const varName = mVar[1];
              pos += varName.length;
              skipWS();
              if (s[pos] === ")") {
                pos++; skipWS();
                if (s[pos] === "(") {
                  pos++;
                  const bodyStart = pos;
                  let depth = 1;
                  while (pos < s.length && depth) {
                    if (s[pos] === "(") depth++;
                    else if (s[pos] === ")") depth--;
                    pos++;
                  }
                  if (!depth) {
                    const desc = s.slice(bodyStart, pos - 1); // inner predicate
                    skipWS();
                    if (s[pos] === ")") {
                      pos++;
                      tokens.push(T.IotaQuant(varName, desc));
                      s = s.slice(pos);
                      continue;
                    }
                  }
                }
              }
            }
          }
        }

        // --- iota-ATOM  (ιx)(ψ) ---------------------------------
        // Treat a single-parenthesis iota construction as a *single* atom,
        // so it can freely appear on either side of binary operators.
        if (s.startsWith("(ι")) {
          const skipWS = () => { while (/\s/.test(s[pos])) pos++; };
          let pos = 1;                      // after first '('
          skipWS();
          if (s[pos] === "ι") {
            pos++;
            const mVar = s.slice(pos).match(/^([A-Za-z\u0370-\u03FF][A-Za-z0-9\u0370-\u03FF]*)/);
            if (mVar) {
              pos += mVar[1].length;
              skipWS();
              if (s[pos] === ")") {
                pos++;                      // end of (ιx)
                const after1 = pos;
                skipWS();
                if (s[pos] === "(") {
                  /* capture the *whole* second parenthesised block, accounting
                     for any nested parentheses inside ψ                       */
                  let depth = 1, i = pos + 1;
                  while (i < s.length && depth) {
                    if (s[i] === "(") depth++;
                    else if (s[i] === ")") depth--;
                    i++;
                  }
                  if (!depth) {
                    const fullAtom = s.slice(0, i);   // "(ιx)(ψ)"
                    tokens.push(T.Atom(fullAtom));
                    s = s.slice(i);
                    continue;
                  }
                }
              }
            }
          }
        }

        // --- atom / predicate ------------------------------

        if (REGEX.atomName.test(s)) {
          const name = s.match(REGEX.atomName)[0];
          let full = name;
          let rest = s.slice(name.length);
          // Grab argument list if any.
          if (rest[0] === "(") {
            let depth = 1;
            let i = 1;
            while (i < rest.length && depth) {
              if (rest[i] === "(") depth++;
              else if (rest[i] === ")") depth--;
              i++;
            }
            if (depth !== 0) throw new Error("Unmatched parentheses in predicate");
            full += rest.slice(0, i);
            rest = rest.slice(i);
          }
          tokens.push(T.Atom(full));
          s = rest;
          continue;
        }

        // --- quantifiers ----------------------------------
        let m;
        if ((m = s.match(REGEX.quantParen))) {
          tokens.push(T.Quant(m[1], m[2]));
          s = s.slice(m[0].length);
          continue;
        }
        if ((m = s.match(REGEX.quant))) {
          tokens.push(T.Quant(m[1], m[2]));
          s = s.slice(m[0].length);
          continue;
        }
        // --- bind-variable in parentheses  (x) -------------------
        if ((m = s.match(REGEX.bindVarParen))) {
          /* A single letter in parentheses, if lowercase, will be
          expected to be a binding variable, as in (x)(x=x).*/
          if (/^[a-z]/.test(m[1])) {
            tokens.push(T.Quant(null, m[1]));
            s = s.slice(m[0].length);
            continue;
          }
          /* If uppercase, it will be assumed to be a formula. */
          /* This is a hack to prevent (∀x)(A) or ∀x(A) from being
          interpreted as a pair of quantifiers on null,
          which gives an error.*/
        }

        // --- negation (plain & dotted) ---------------------
        if (notationMode === "dots") {
          if ((m = s.match(REGEX.dottedNeg))) {
            const [, ldots, op, rdots] = m;
            const weight = Math.max(countDots(ldots), countDots(rdots));
            if (weight > 0) {                        // only treat as dotted if dots found
              tokens.push(T.Not(op, weight));
              s = s.slice(m[0].length);
              continue;
            }
          }
        }
        if ((m = s.match(REGEX.neg))) {
          tokens.push(T.Not(m[1]));                  // ordinary, weight-less NOT
          s = s.slice(m[0].length);
          continue;
        }

        // --- binary operator -------------------------------
        if (notationMode === "dots") {
          if ((m = s.match(REGEX.dottedBinary))) {
            const [, ldots, op, rdots] = m;
            const weight = Math.max(countDots(ldots), countDots(rdots)); // tolerate one-sided / uneven dot strings
            tokens.push(T.Binary(op, weight));
            s = s.slice(m[0].length);
            continue;
          }
        } else {
          if ((m = s.match(REGEX.binary))) {
            tokens.push(T.Binary(m[1], 0));
            s = s.slice(m[0].length);
            continue;
          }
        }

        // --- parentheses ----------------------------------
        if (s[0] === "(") {
          tokens.push(T.LParen);
          s = s.slice(1);
          continue;
        }
        if (s[0] === ")") {
          tokens.push(T.RParen);
          s = s.slice(1);
          continue;
        }

        // --- anything else → error ------------------------
        throw new Error("Unexpected character: " + s[0]);
      }

      return tokens;
    }

    /*****************
     *  Parser base  *
     *****************/

    /**
     * Walk helper that executes a callback on binary nodes.
     */
    const walkBinary = (node, fn) => {
      if (!node) return;
      if (node.type === "Binary") fn(node);
      if (node.type === "Binary") {
        walkBinary(node.left, fn);
        walkBinary(node.right, fn);
      } else if (node.type === "Not" || node.type === "Quant") {
        walkBinary(node.child, fn);
      }
      if (node.type === "IotaQuant") {
        walkBinary(node.desc, fn);
        walkBinary(node.child, fn);
      }
    };

    /**
     * Parse for dot‑notation.
     * Uses operator weight to create precedence levels.
     */
    function parseDots(tokens) {
      if (!tokens.length) return null;

      const opToks = tokens.filter(
        (t) => t.type === "Binary" || (t.type === "Not" && t.weight !== undefined)
      );
      const maxWeight = opToks.length ? Math.max(...opToks.map((t) => t.weight)) : 0;
      opToks.forEach((t) => (t.weight = maxWeight - t.weight));

      let idx = 0;

      function parseLevel(level) {
        if (level > maxWeight) return parsePrimary();
        /* prefix dotted negations of this very level */
        const prefixes = [];
        while (
        tokens[idx] &&
        tokens[idx].type === "Not" &&
        tokens[idx].weight !== undefined &&
        tokens[idx].weight === level
        ) {
        prefixes.push(tokens[idx++]);
        }
        let node = parseLevel(level + 1);
        /* apply dotted negations right-to-left */
        while (prefixes.length) {
        const tok = prefixes.pop();
        node = { type: "Not", op: tok.op, child: node };
        }
        const nodes = [node];
        const ops = [];
        while (tokens[idx] && tokens[idx].type === "Binary" && tokens[idx].weight === level) {
          ops.push(tokens[idx].op);
          idx++;
          nodes.push(parseLevel(level + 1));
        }
        // Right fold to preserve grouping order.
        let subtree = nodes.pop();
        while (nodes.length) {
          const left = nodes.pop();
          const op = ops.pop();
          subtree = { type: "Binary", op, left, right: subtree };
        }
        return subtree;
      }

      function parsePrimary() {
        const t = tokens[idx];
        if (!t) return null;
        switch (t.type) {
          case "Atom":
            idx++;
            return t;
          case "Not":
            idx++;
            return { type: "Not", op: t.op, child: parsePrimary() };
          case "Quant":
            idx++;
            return { type: "Quant", sym: t.sym, varName: t.varName, child: parsePrimary() };
          case "IotaQuant": {
            idx++;
            const innerToks = lexer(t.desc, "dots"); /* use “dots” because we are already in the dot-notation parser */
            const innerAst  = parseDots(innerToks);
            return {
              type : "IotaQuant",
              varName : t.varName,
              desc : innerAst,
              child : parsePrimary(),
            };
          }
          case "LPAREN":
            idx++;
            const expr = parseLevel(0);
            if (tokens[idx] && tokens[idx].type === "RPAREN") idx++;
            return expr;
          default:
            throw new Error("Parse error at token " + JSON.stringify(t));
        }
      }

      return parseLevel(0);
    }

    /**
     * Left‑associative, parentheses‑only precedence parser (bracket notation).
     */
    function parseBrackets(tokens) {
      let idx = 0;

      function parseExpr() {
        let node = parsePrimary();
        while (tokens[idx] && tokens[idx].type === "Binary") {
          const opTok = tokens[idx++];
          const right = parseExpr(); // right‑recursive → left‑associative
          node = { type: "Binary", op: opTok.op, left: node, right };
        }
        return node;
      }

      function parsePrimary() {
        const t = tokens[idx];
        if (!t) return null;
        switch (t.type) {
          case "Atom":
            idx++;
            return t;
          case "Not":
            idx++;
            return { type: "Not", op: t.op, child: parsePrimary() };
          case "Quant":
            idx++;
            return { type: "Quant", sym: t.sym, varName: t.varName, child: parsePrimary() };
          case "IotaQuant": {
            idx++;
            const innerToks = lexer(t.desc, "brackets"); /* use “brackets” because we are already in the bracket-notation parser */
            const innerAst  = parseBrackets(innerToks);
            return {
              type : "IotaQuant",
              varName : t.varName,
              desc : innerAst,
              child : parsePrimary(),
            };
          }
          case "LPAREN":
            idx++;
            const expr = parseExpr();
            if (tokens[idx] && tokens[idx].type === "RPAREN") idx++;
            return expr;
          default:
            throw new Error("Parse error at token " + JSON.stringify(t));
        }
      }

      return parseExpr();
    }

    /*****************
     *  Annotation   *
     *****************/

    /** Annotate depths (for later dot‑serialization). */
    function annotateDepth(node, depth = 0) {
      if (!node) return;
      if (node.type === "Binary") {
        node.depth = depth;
        annotateDepth(node.left, depth + 1);
        annotateDepth(node.right, depth + 1);
      } else if (node.type === "Not" || node.type === "Quant") {
        annotateDepth(node.child, depth);
      } else if (node.type === "IotaQuant") {
        annotateDepth(node.desc, depth);
        annotateDepth(node.child, depth);
      }

    }

    /** Assign dot‑weights based on annotated depth (root = max weight). */
    function assignWeights(node) {
      const binaries = [];
      walkBinary(node, (n) => binaries.push(n));
      const maxD = binaries.length ? Math.max(...binaries.map((n) => n.depth)) : 0;
      binaries.forEach((n) => (n.weight = maxD - n.depth));
    }

    /*********************
     *  Serialisation    *
     *********************/

    function toBrackets(node, root = true) {
      switch (node.type) {
        case "Atom":
          return node.value;
        case "Not": {
          const ch = toBrackets(node.child, false);
          return node.op + (ch.startsWith("(") ? ch : ch);
        }
        case "Quant": {
          const prefix = node.sym ? `(${node.sym}${node.varName})` : `(${node.varName})`;
          return prefix + toBrackets(node.child, false);
        }
        case "IotaQuant": {
          const prefix = `((ι${node.varName})(${toBrackets(node.desc, false)}))`;
          return prefix + toBrackets(node.child, false);
        }
        case "Binary": {
          const left = toBrackets(node.left, false);
          const right = toBrackets(node.right, false);
          const str = `${left} ${node.op} ${right}`;
          return root ? str : `(${str})`;
        }
      }
    }

    function toDots(node, dotNeg = false, strictHier = false) {
      switch (node.type) {
        case "Atom":
          return node.value;
        case "Not": {
          if (dotNeg && node.child.type === "Binary") {
            const w    = (node.child.weight ?? 0) + 1;
            const pref = node.op + dotStr(w);
            return `${pref} ${toDots(node.child, dotNeg, strictHier)}`;
          }
          /* ordinary form — keep the brackets if the body is molecular */
          const inner = toDots(node.child, dotNeg, strictHier);
          return node.op + (node.child.type === "Binary" ? `(${inner})` : inner);
        }
        case "Quant": {
          const prefix = node.sym ? `(${node.sym}${node.varName})`
                                  : `(${node.varName})`;
          const body   = toDots(node.child, dotNeg, strictHier);
          return ["Atom","Not","Quant","IotaQuant"].includes(node.child.type)
                 ? prefix + body
                 : `${prefix}(${body})`;
        }
        case "IotaQuant": {
          const prefix = `((ι${node.varName})(${toDots(node.desc, dotNeg, strictHier)}))`;
          const body   = toDots(node.child, dotNeg, strictHier);
          return ["Atom","Not","Quant","IotaQuant"].includes(node.child.type)
                 ? prefix + body
                 : `${prefix}(${body})`;
        }

        case "Binary": {
          let w = node.weight;

          if (strictHier && dotNeg) {
            /* if either child is a dotted-NOT whose dot-weight ≥ w,
               promote this operator by one level                        */
            const childNegWeight = (n) =>
              n.type === "Not" && n.child.type === "Binary" ? (n.child.weight ?? 0) + 1 : -1;

            const needBump =
              Math.max(childNegWeight(node.left), childNegWeight(node.right)) >= w;

            if (needBump) w += 1;
          }

          /* ▸  allow weight-relaxation when Dot-Negation is OFF
             ---------------------------------------------------
             If neither operand is itself a naked Binary node, we can safely
             write the outer operator without dots — parentheses or unary
             wrappers already fix the grouping.                            */
          if (!dotNeg && w > 0) {
            const leftIsBin  = node.left.type  === "Binary";
            const rightIsBin = node.right.type === "Binary";
            if (!leftIsBin && !rightIsBin) {
              w = 0;           // drop to the bare operator (no dots)
            }
          }

          const left  = toDots(node.left,  dotNeg, strictHier);
          const right = toDots(node.right, dotNeg, strictHier);
          return `${left} ${dottedRep(w, node.op)} ${right}`;
        }
      }
    }

    /****************
     *  UI Binding  *
     ****************/

    const qs            = (sel) => document.querySelector(sel);
    const $in           = qs("#inputFormula");
    const $out          = qs("#outputFormula");
    const $dotNegChk    = qs("#dotNegChk");
    const $dotNegOption = qs("#dotNegOption");
    const $strictChk     = qs("#strictHierChk");

    /* show the second checkbox only when dot-negation is enabled */
    $dotNegChk.addEventListener("change", () => {
      $strictChk.parentElement.style.display =
        $dotNegChk.checked ? "" : "none";
    });
    /* keep it hidden at first */
    $strictChk.parentElement.style.display = "none";

    /* show / hide the whole option block as before */
    function toggleDotNegUI() {
      const mode = qs("input[name=mode]:checked").value;
      $dotNegOption.style.display = mode === "bracketsToDots" ? "" : "none";
    }
    document.querySelectorAll("input[name=mode]").forEach((r) =>
      r.addEventListener("change", toggleDotNegUI)
    );
    toggleDotNegUI();   // initial state

    /* main click handler – now grabs the new flag */
    qs("#convertBtn").addEventListener("click", () => {
      const mode        = qs("input[name=mode]:checked").value;
      const val         = $in.value.trim();
      const dotNeg      = $dotNegChk.checked;
      const strictHier  = dotNeg && $strictChk.checked;   // only relevant if dotNeg

      try {
        let ast, result;
        if (mode === "dotsToBrackets") {
          const tokens = lexer(val, "dots");
          ast    = parseDots(tokens);
          result = toBrackets(ast);
        } else {
          const tokens = lexer(val, "brackets");
          ast = parseBrackets(tokens);
          annotateDepth(ast);
          assignWeights(ast);
          result = toDots(ast, dotNeg, strictHier);
        }
        $out.textContent = result;
      } catch (err) {
        $out.textContent = "Error: " + err.message;
      }
    });
    
  </script>
</body>
</html>
