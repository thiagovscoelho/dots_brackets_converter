<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The Dots–Brackets Converter</title>
  <style>
    body { font-family: sans-serif; max-width: 800px; margin: 2em auto; padding: 0 1em; }
    h1 { text-align: center; }
    textarea, pre { width: 100%; font-family: monospace; font-size: 1rem; }
    .controls { margin: 1em 0; }
    .controls label { margin-right: 1em; }
    button { padding: 0.5em 1em; font-size: 1rem; }
    pre { background: #f5f5f5; padding: 1em; white-space: pre-wrap; }
  </style>
</head>
<body>
  <h1>The Dots–Brackets Converter</h1>
  <div class="controls">
    <label><input type="radio" name="mode" value="dotsToBrackets" checked> Dots → Brackets</label>
    <label><input type="radio" name="mode" value="bracketsToDots"> Brackets → Dots</label>
  </div>
  <textarea id="inputFormula" rows="4" placeholder="Enter your formula..."></textarea>
  <div class="controls">
    <button id="convertBtn">Convert</button>
  </div>
  <pre id="outputFormula"></pre>

  <script>
    // Count dots for precedence
    function countDots(s) {
      return (s.match(/\./g) || []).length + (s.match(/:/g) || []).length * 2;
    }

    // Operators & regex setup
    const opList = [
      "&&","||","∥",
      "⇔","⇋","↔",
      "⇏","⊅","⇎","↛","⇍",
      "⇒","⊃","→",
      "∧","•","⋅","&",
      "↑",
      "∨","+","∣","|",
      "↓",
      "⊙","⊕",
      "≡","≢","↮",
      "⇐","⊂","←",
      "⊄","↚",
      "=", "=df"
    ];
    const opPattern = opList.map(o => o.replace(/[-/\\^$*+?.()|[\]{}]/g,'\\$&')).sort((a,b)=>b.length-a.length).join('|');
    const dottedOpRe = new RegExp('^([.:]*)(' + opPattern + ')([.:]*)');
    const opRe = new RegExp('^(' + opPattern + ')');

    // Quantifier regex (including Unicode)
    const quantParensRe = /^\(\s*(∀|∃)([A-Za-z\u0370-\u03FF][A-Za-z0-9\u0370-\u03FF]*)\s*\)/;
    const quantRe = /^(∀|∃)([A-Za-z\u0370-\u03FF][A-Za-z0-9\u0370-\u03FF]*)/;
    const bindVarRe = /^\(\s*([A-Za-z\u0370-\u03FF])\s*\)/;

    // Negation & atom/predicate regex
    const negRe = /^(NOT|¬|−|∼|~)/;
    const atomNameRe = /^[A-Za-z\u0370-\u03FF][A-Za-z0-9\u0370-\u03FF]*/;

    // Tokenize dot notation
    function tokenizeDots(input) {
      const tokens = [];
      let pos = 0;
      while (pos < input.length) {
        const rest = input.slice(pos);
        const ws = rest.match(/^\s+/);
        if (ws) { pos += ws[0].length; continue; }
        let m;
        // Atom or predicate
        if (rest[0].match(/[A-Za-z\u0370-\u03FF]/)) {
          const name = rest.match(atomNameRe)[0];
          let full = name;
          let np = pos + name.length;
          if (input[np] === '(') {
            let depth = 1, i = np + 1;
            while (i < input.length && depth) {
              if (input[i] === '(') depth++;
              else if (input[i] === ')') depth--;
              i++;
            }
            if (depth !== 0) throw new Error('Unmatched parens in ' + name);
            full += input.slice(np, i);
            tokens.push({type:'Atom', value:full});
            pos = i;
          } else {
            tokens.push({type:'Atom', value:full});
            pos += name.length;
          }
          continue;
        }
        // Quantifiers
        if (m = rest.match(quantParensRe)) {
          tokens.push({type:'Quant', sym:m[1], varName:m[2]}); pos += m[0].length; continue;
        }
        if (m = rest.match(quantRe)) {
          tokens.push({type:'Quant', sym:m[1], varName:m[2]}); pos += m[0].length; continue;
        }
        if (m = rest.match(bindVarRe)) {
          tokens.push({type:'Quant', sym:null, varName:m[1]}); pos += m[0].length; continue;
        }
        // Negation
        if (m = rest.match(negRe)) {
          tokens.push({type:'Not', op:m[1]}); pos += m[0].length; continue;
        }
        // Dotted binary op
        if (m = rest.match(dottedOpRe)) {
          const [full, ld, op, rd] = m;
          const w = countDots(ld);
          if (countDots(rd) !== w) throw new Error('Mismatched dots in ' + full);
          tokens.push({type:'Binary', op, weight:w}); pos += full.length; continue;
        }
        // Parens
        if (rest[0] === '(') { tokens.push({type:'LPAREN'}); pos++; continue; }
        if (rest[0] === ')') { tokens.push({type:'RPAREN'}); pos++; continue; }
        throw new Error('Unexpected char: ' + rest[0]);
      }
      return tokens;
    }

    // Tokenize bracketed notation
    function tokenizeBrackets(input) {
      const tokens = [];
      let pos = 0;
      while (pos < input.length) {
        const rest = input.slice(pos);
        const ws = rest.match(/^\s+/);
        if (ws) { pos += ws[0].length; continue; }
        let m;
        // Atom/predicate
        if (rest[0].match(/[A-Za-z\u0370-\u03FF]/)) {
          const name = rest.match(atomNameRe)[0];
          let full = name;
          let np = pos + name.length;
          if (input[np] === '(') {
            let depth = 1, i = np + 1;
            while (i < input.length && depth) {
              if (input[i] === '(') depth++;
              else if (input[i] === ')') depth--;
              i++;
            }
            if (depth !== 0) throw new Error('Unmatched parens in ' + name);
            full += input.slice(np, i);
            tokens.push({type:'Atom', value:full}); pos = i;
          } else {
            tokens.push({type:'Atom', value:full}); pos += name.length;
          }
          continue;
        }
        // Quantifiers
        if (m = rest.match(quantParensRe)) { tokens.push({type:'Quant', sym:m[1], varName:m[2]}); pos += m[0].length; continue; }
        if (m = rest.match(quantRe)) { tokens.push({type:'Quant', sym:m[1], varName:m[2]}); pos += m[0].length; continue; }
        if (m = rest.match(bindVarRe)) { tokens.push({type:'Quant', sym:null, varName:m[1]}); pos += m[0].length; continue; }
        // Negation
        if (m = rest.match(negRe)) { tokens.push({type:'Not', op:m[1]}); pos += m[0].length; continue; }
        // Binary op
        if (m = rest.match(opRe)) { tokens.push({type:'Binary', op:m[1], weight:0}); pos += m[0].length; continue; }
        // Parens
        if (rest[0] === '(') { tokens.push({type:'LPAREN'}); pos++; continue; }
        if (rest[0] === ')') { tokens.push({type:'RPAREN'}); pos++; continue; }
        throw new Error('Unexpected char: ' + rest[0]);
      }
      return tokens;
    }

    // Parse Dots AST
    function parseDots(tokens) {
      const wsArr = tokens.filter(t => t.type==='Binary').map(t => t.weight);
      const maxW = wsArr.length ? Math.max(...wsArr) : 0;
      tokens.forEach(t => { if (t.type==='Binary') t.weight = maxW - t.weight; });
      let idx = 0;
      function parseLevel(level) {
        if (level > maxW) return parsePrimary();
        let node = parseLevel(level+1);
        const seqN = [node], seqO = [];
        while (tokens[idx] && tokens[idx].type==='Binary' && tokens[idx].weight===level) {
          seqO.push(tokens[idx].op);
          idx++;
          seqN.push(parseLevel(level+1));
        }
        let subtree = seqN.pop();
        while (seqN.length) {
          const left = seqN.pop(), op = seqO.pop();
          subtree = {type:'Binary', left, right: subtree, op};
        }
        return subtree;
      }
      function parsePrimary() {
        const t = tokens[idx];
        if (!t) return null;
        if (t.type==='Not') { idx++; const child = parsePrimary(); return {type:'Not', op:t.op, child}; }
        if (t.type==='Quant') { idx++; const child = parsePrimary(); return {type:'Quant', sym:t.sym, varName:t.varName, child}; }
        if (t.type==='Atom') { idx++; return {type:'Atom', value:t.value}; }
        if (t.type==='LPAREN') { idx++; const expr = parseLevel(0); if(tokens[idx]&&tokens[idx].type==='RPAREN') idx++; return expr; }
        throw new Error('Parse error at ' + JSON.stringify(t));
      }
      return parseLevel(0);
    }

    // Parse Brackets AST
    function parseBrackets(tokens) {
      let idx = 0;
      function parseExpr() {
        let node = parsePrimary();
        while (tokens[idx] && tokens[idx].type==='Binary') {
          const op = tokens[idx].op; idx++;
          const right = parseExpr();
          node = {type:'Binary', left: node, right, op};
        }
        return node;
      }
      function parsePrimary() {
        const t = tokens[idx]; if (!t) return null;
        if (t.type==='Not') { idx++; const child = parsePrimary(); return {type:'Not', op:t.op, child}; }
        if (t.type==='Quant') { idx++; const child = parsePrimary(); return {type:'Quant', sym:t.sym, varName:t.varName, child}; }
        if (t.type==='Atom') { idx++; return {type:'Atom', value:t.value}; }
        if (t.type==='LPAREN') { idx++; const expr = parseExpr(); if(tokens[idx]&&tokens[idx].type==='RPAREN') idx++; return expr; }
        throw new Error('Parse error at ' + JSON.stringify(t));
      }
      return parseExpr();
    }

    // Depth annotation & weight assignment
    function annotateDepth(n, d=0) {
      if (n.type==='Binary') { n.depth=d; annotateDepth(n.left, d+1); annotateDepth(n.right, d+1); }
      if (n.type==='Not' || n.type==='Quant') annotateDepth(n.child, d);
    }
    function assignWeights(n) {
      const arr = [];
      (function c(x){ if(x.type==='Binary'){ arr.push(x); c(x.left); c(x.right);} if(x.type==='Not'||x.type==='Quant'){c(x.child);} })(n);
      const maxD = arr.length ? Math.max(...arr.map(x=>x.depth)) : 0;
      arr.forEach(x=>x.weight = maxD - x.depth);
    }

    // Serialize AST to brackets
    function toBrackets(n, isRoot=true) {
      if (n.type==='Atom') return n.value;
      if (n.type==='Not') {
        const ch = toBrackets(n.child, false);
        return n.op + (ch.startsWith('(') ? ch : ch);
      }
      if (n.type==='Quant') {
        const prefix = n.sym ? '('+n.sym+n.varName+')' : '('+n.varName+')';
        return prefix + toBrackets(n.child, false);
      }
      const left = toBrackets(n.left, false);
      const right = toBrackets(n.right, false);
      const s = left + ' ' + n.op + ' ' + right;
      return isRoot ? s : '('+s+')';
    }

    // Build dotted arrow
    function repFromWeight(g, op) {
      let left, right;
      if(g%2===0){ const c=':'.repeat(g/2); left=right=c; }
      else{ const c=':'.repeat((g-1)/2); left='.'+c; right=c+'.'; }
      return left+op+right;
    }

    // Serialize AST to dots
    function toDots(n) {
      if (n.type==='Atom') return n.value;
      if (n.type==='Not') {
        if (n.child.type==='Binary') return n.op + toBrackets(n.child, false);
        return n.op + toDots(n.child);
      }
      if (n.type==='Quant') {
        const prefix = n.sym ? '('+n.sym+n.varName+')' : '('+n.varName+')';
        const body = toDots(n.child);
        if (['Atom','Not','Quant'].includes(n.child.type)) return prefix+body;
        return prefix+'('+body+')';
      }
      const left = toDots(n.left);
      const right = toDots(n.right);
      return left + ' ' + repFromWeight(n.weight, n.op) + ' ' + right;
    }

    // Conversion handler
    document.getElementById('convertBtn').addEventListener('click', () => {
      const mode = document.querySelector('input[name=mode]:checked').value;
      const input = document.getElementById('inputFormula').value;
      try {
        let ast, out;
        if (mode === 'dotsToBrackets') {
          ast = parseDots(tokenizeDots(input));
          out = toBrackets(ast);
        } else {
          ast = parseBrackets(tokenizeBrackets(input));
          annotateDepth(ast);
          assignWeights(ast);
          out = toDots(ast);
        }
        document.getElementById('outputFormula').textContent = out;
      } catch (e) {
        document.getElementById('outputFormula').textContent = 'Error: '+e.message;
      }
    });
  </script>
</body>
</html>
